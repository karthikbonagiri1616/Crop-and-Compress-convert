<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>KARTHIK ACADEMY ‚Äî Crop, Compress & Convert</title>

<link href="https://unpkg.com/cropperjs@1.5.13/dist/cropper.min.css" rel="stylesheet"/>
<script src="https://unpkg.com/cropperjs@1.5.13/dist/cropper.min.js"></script>

<style>
  :root{
    --bg1:#e8f5ff; /* light blue */
    --accentA:#0072ff; /* blue */
    --accentB:#00c853; /* green */
    --card:#ffffff;
    --muted:#67748a;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family: "Segoe UI", Roboto, Arial, sans-serif;
    background: linear-gradient(135deg,var(--bg1),#f7fff1);
    color:#21343b;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    min-height:100vh;
    padding:28px;
    display:flex;
    align-items:flex-start;
    justify-content:center;
  }

  .wrap{width:100%;max-width:1000px}
  header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    margin-bottom:18px;
  }
  header .title{
    font-size:28px;
    font-weight:800;
    letter-spacing:1px;
    background:linear-gradient(90deg,var(--accentA),var(--accentB));
    -webkit-background-clip:text;
    -webkit-text-fill-color:transparent;
  }
  header .subtitle{color:var(--muted); font-weight:600; font-size:14px}

  .card{
    background:var(--card);
    border-radius:12px;
    padding:18px;
    box-shadow:0 10px 30px rgba(16,39,63,0.08);
  }

  .top-row{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-bottom:12px}
  .file-input {
    position:relative;
  }
  .btn{
    display:inline-flex;
    align-items:center;
    gap:8px;
    padding:10px 14px;
    border-radius:10px;
    border:none;
    cursor:pointer;
    font-weight:700;
    color:white;
  }
  .btn.upload{background:linear-gradient(90deg,var(--accentA),#2aa1ff);}
  .btn.crop{background:linear-gradient(90deg,#00b894,var(--accentB));}
  .btn.convert{background:linear-gradient(90deg,var(--accentA),var(--accentB));}
  .btn.reset{background:#f44336}

  input[type=file]{display:none}

  /* preview area */
  .preview-wrap{display:flex;gap:18px;align-items:flex-start;flex-wrap:wrap}
  .preview{
    width:420px;
    max-width:100%;
    border-radius:10px;
    overflow:hidden;
    border:1px solid #e6eef7;
    background:#fbfdff;
    padding:8px;
    text-align:center;
  }
  .preview img{
    max-width:100%;
    max-height:60vh;
    object-fit:contain;
    display:block;
    margin:0 auto;
  }

  /* controls */
  .controls{
    min-width:260px;
    max-width:360px;
    display:flex;
    flex-direction:column;
    gap:12px;
  }
  .field{display:flex;flex-direction:column;gap:6px}
  label.small{font-size:13px;color:var(--muted);font-weight:700}
  select,input[type=number],input[type=range]{
    padding:8px;border-radius:8px;border:1px solid #d7e6fb;background:#fff;
  }
  .hint{font-size:12px;color:#6b7280}

  /* modal cropper */
  #cropModal{
    position:fixed;inset:0;background:rgba(0,0,0,0.65);display:none;align-items:center;justify-content:center;z-index:9999;padding:16px;
  }
  .cropBox{
    width:90%;
    max-width:900px;
    background:#fff;
    border-radius:12px;
    padding:14px;
    box-shadow:0 20px 50px rgba(0,0,0,0.4);
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:10px;
  }
  #cropImage{
    max-width:100%;
    max-height:70vh;
    object-fit:contain;
    border-radius:6px;
  }
  .cropActions{display:flex;gap:10px;align-items:center}
  .cropZoom{width:220px}

  /* small responsive */
  @media (max-width:880px){
    .preview-wrap{flex-direction:column;align-items:center}
    .controls{width:100%}
  }

  .note{font-size:13px;color:var(--muted)}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <div class="title">KARTHIK ACADEMY</div>
        <div class="subtitle">Crop ‚Ä¢ Compress ‚Ä¢ Convert</div>
      </div>
      <div class="note">Professional blue‚Äìgreen theme</div>
    </header>

    <div class="card">
      <div class="top-row">
        <div class="file-input">
          <label class="btn upload" for="fileInput">üì§ Upload Image</label>
          <input id="fileInput" type="file" accept="image/*">
        </div>

        <button id="openCropBtn" class="btn crop" style="display:none">‚úÇÔ∏è Crop Image</button>
        <button id="resetBtn" class="btn reset" style="display:none">Reset</button>
      </div>

      <div class="preview-wrap">
        <div class="preview">
          <div class="note" style="margin-bottom:8px">Preview</div>
          <img id="previewImage" alt="Preview will appear here">
        </div>

        <div class="controls">
          <div class="field">
            <label class="small">Convert To</label>
            <select id="outFormat">
              <option value="image/jpeg">JPG (recommended)</option>
              <option value="image/png">PNG</option>
              <option value="image/webp">WebP</option>
            </select>
          </div>

          <div class="field">
            <label class="small">Quality (for JPG / WebP)</label>
            <input id="qualityRange" type="range" min="0.1" max="1" step="0.05" value="0.85">
            <div class="hint" id="qualityVal">Quality: 85%</div>
          </div>

          <div class="field">
            <label class="small">Target size (KB) ‚Äî optional</label>
            <input id="targetKB" type="number" min="0" placeholder="e.g. 200 (0 = ignore)" />
            <div class="hint">If set, tool will try quality ‚Üí downscale to reach target size.</div>
          </div>

          <div class="field">
            <button id="convertDownloadBtn" class="btn convert" disabled>‚¨áÔ∏è Convert & Download</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Crop Modal -->
  <div id="cropModal" aria-hidden="true">
    <div class="cropBox">
      <img id="cropImage" alt="">
      <div class="cropActions">
        <input id="cropZoom" class="cropZoom" type="range" min="0.2" max="3" step="0.01" value="1">
        <button id="cropSaveBtn" class="btn crop">Save Crop</button>
        <button id="cropCancelBtn" class="btn reset">Cancel</button>
      </div>
    </div>
  </div>

<script>
/* Globals */
const fileInput = document.getElementById('fileInput');
const previewImage = document.getElementById('previewImage');
const openCropBtn = document.getElementById('openCropBtn');
const resetBtn = document.getElementById('resetBtn');
const outFormat = document.getElementById('outFormat');
const qualityRange = document.getElementById('qualityRange');
const qualityVal = document.getElementById('qualityVal');
const targetKB = document.getElementById('targetKB');
const convertDownloadBtn = document.getElementById('convertDownloadBtn');

const cropModal = document.getElementById('cropModal');
const cropImage = document.getElementById('cropImage');
const cropZoom = document.getElementById('cropZoom');
const cropSaveBtn = document.getElementById('cropSaveBtn');
const cropCancelBtn = document.getElementById('cropCancelBtn');

let originalFile = null;
let originalURL = null;
let cropper = null;
let croppedCanvas = null; // stores cropped result canvas

/* Helpers */
function enableControls(enabled){
  openCropBtn.style.display = enabled ? 'inline-flex' : 'none';
  resetBtn.style.display = enabled ? 'inline-flex' : 'none';
  convertDownloadBtn.disabled = !enabled;
}

/* Update quality label */
qualityRange.addEventListener('input', ()=>{
  qualityVal.textContent = `Quality: ${Math.round(parseFloat(qualityRange.value)*100)}%`;
});

/* File handling */
fileInput.addEventListener('change', (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  loadOriginalFile(f);
});

function loadOriginalFile(file){
  // reset previous
  if(originalURL) URL.revokeObjectURL(originalURL);
  originalFile = file;
  originalURL = URL.createObjectURL(file);
  previewImage.src = originalURL;
  croppedCanvas = null; // reset cropped
  enableControls(true);
}

/* Reset */
resetBtn.addEventListener('click', ()=>{
  if(originalURL) previewImage.src = originalURL;
  croppedCanvas = null;
});

/* Open crop modal */
openCropBtn.addEventListener('click', ()=>{
  if(!originalFile && !previewImage.src) return;
  // set crop image source: if cropped exists use that, else original
  if(croppedCanvas){
    cropImage.src = croppedCanvas.toDataURL();
  } else {
    cropImage.src = originalURL;
  }
  openCropModal();
});

function openCropModal(){
  cropModal.style.display = 'flex';
  cropModal.setAttribute('aria-hidden','false');
  // destroy previous
  if(cropper){ try{ cropper.destroy(); }catch(e){} cropper=null; }
  cropImage.onload = ()=>{
    cropper = new Cropper(cropImage, {
      viewMode:1,
      autoCropArea:0.9,
      movable:true,
      zoomable:true,
      responsive:true,
    });
    cropZoom.value = 1;
  };
}

/* crop zoom slider */
cropZoom.addEventListener('input', ()=>{
  if(cropper){
    try{ cropper.zoomTo(parseFloat(cropZoom.value)); }catch(e){}
  }
});

/* save crop */
cropSaveBtn.addEventListener('click', async ()=>{
  if(!cropper) return;
  try{
    const canvas = cropper.getCroppedCanvas({ fillColor:'#fff' });
    if(!canvas) throw new Error('Crop failed');
    // Keep croppedCanvas for further ops
    croppedCanvas = canvas;
    // update preview
    previewImage.src = canvas.toDataURL('image/png');
    // close
    closeCropModal();
  }catch(err){
    alert('Crop failed: '+err.message);
  }
});

cropCancelBtn.addEventListener('click', closeCropModal);
function closeCropModal(){
  if(cropper){ try{ cropper.destroy(); }catch(e){} cropper=null; }
  cropModal.style.display='none';
  cropModal.setAttribute('aria-hidden','true');
}

/* Convert & Download logic */
convertDownloadBtn.addEventListener('click', async ()=>{
  // get canvas to work on: croppedCanvas or create from previewImage (original)
  let srcCanvas;
  if(croppedCanvas){
    srcCanvas = croppedCanvas;
  } else {
    // create canvas from previewImage (originalURL)
    if(!previewImage.src) { alert('Please upload an image first'); return; }
    srcCanvas = await imageToCanvas(previewImage);
  }

  const outType = outFormat.value;
  const quality = parseFloat(qualityRange.value);
  const maxKB = Math.max(0, parseInt(targetKB.value) || 0);

  // show user busy state
  convertDownloadBtn.textContent = 'Processing...';
  convertDownloadBtn.disabled = true;

  try{
    const blob = await compressCanvasToTarget(srcCanvas, outType, quality, maxKB);
    // download
    const ext = outType === 'image/png' ? 'png' : (outType === 'image/webp' ? 'webp' : 'jpg');
    const name = (originalFile && originalFile.name) ? originalFile.name.replace(/\.[^.]+$/,'') : 'image';
    const filename = `${name}-converted.${ext}`;

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url),5000);
  }catch(err){
    console.error(err);
    alert('Conversion failed: '+ (err.message || err));
  }finally{
    convertDownloadBtn.textContent = '‚¨áÔ∏è Convert & Download';
    convertDownloadBtn.disabled = false;
  }
});

/* Utility: draw image element to canvas at its natural resolution */
function imageToCanvas(imgEl){
  return new Promise((resolve, reject)=>{
    const img = new Image();
    img.onload = ()=>{
      const canvas = document.createElement('canvas');
      canvas.width = img.naturalWidth || img.width;
      canvas.height = img.naturalHeight || img.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img,0,0,canvas.width,canvas.height);
      resolve(canvas);
    };
    img.onerror = (e)=> reject(e);
    // use current src (dataurl or object url)
    img.src = imgEl.src;
  });
}

/* Utility: canvas -> blob promise */
function canvasToBlob(canvas, type='image/jpeg', quality=0.92){
  return new Promise((resolve)=>{
    canvas.toBlob(blob => resolve(blob), type, quality);
  });
}

/* Main compression attempt: tries quality decreasing, then downscale if needed */
async function compressCanvasToTarget(srcCanvasInput, outType, startQuality, maxKB){
  // if no target KB, just convert with given quality
  if(!maxKB || maxKB <= 0){
    const blob = await canvasToBlob(srcCanvasInput, outType, (outType==='image/png')?1:startQuality);
    return blob;
  }

  // Make a clone canvas we can downscale progressively
  let canvas = document.createElement('canvas');
  canvas.width = srcCanvasInput.width;
  canvas.height = srcCanvasInput.height;
  let ctx = canvas.getContext('2d');
  ctx.drawImage(srcCanvasInput,0,0,canvas.width,canvas.height);

  // Try decreasing quality first
  let quality = startQuality;
  let blob = await canvasToBlob(canvas, outType, (outType==='image/png')?1:quality);
  // Loop quality down
  while(blob.size/1024 > maxKB && quality > 0.05){
    quality = Math.max(0.05, quality - 0.07);
    blob = await canvasToBlob(canvas, outType, (outType==='image/png')?1:quality);
  }

  // If still too big, downscale stepwise
  let attempts = 0;
  while(blob.size/1024 > maxKB && attempts < 12 && (canvas.width>200 || canvas.height>200)){
    attempts++;
    const newW = Math.round(canvas.width * 0.85);
    const newH = Math.round(canvas.height * 0.85);
    const newCanvas = document.createElement('canvas');
    newCanvas.width = newW;
    newCanvas.height = newH;
    const newCtx = newCanvas.getContext('2d');
    // draw scaled
    newCtx.drawImage(canvas,0,0,canvas.width,canvas.height,0,0,newW,newH);
    canvas = newCanvas;
    // try again with reasonable quality (not lower than 0.45)
    const useQuality = Math.max(0.45, quality);
    blob = await canvasToBlob(canvas, outType, (outType==='image/png')?1:useQuality);
    // slightly reduce quality if still big
    if(blob.size/1024 > maxKB){
      quality = Math.max(0.25, quality - 0.07);
    }
  }

  return blob;
}

/* enable convert when file present */
(function(){
  // watch previewImage src
  const obs = new MutationObserver(()=> {
    const has = !!previewImage.src;
    enableControls(has);
  });
  obs.observe(previewImage, { attributes:true, attributeFilter:['src']});
})();

/* cleanup objecturls on unload */
window.addEventListener('beforeunload', ()=>{
  try{ if(originalURL) URL.revokeObjectURL(originalURL); }catch(e){}
});
</script>
</body>
</html>
